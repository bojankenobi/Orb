<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Orbit: Ultimate</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            transition: background-color 1s;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .top-hud {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
        }

        .score-container {
            text-align: center;
            color: #fff;
            text-shadow: 0 0 10px currentColor;
        }

        #score {
            font-size: 4rem;
            font-weight: bold;
            line-height: 1;
            transition: transform 0.1s;
        }

        #level-display {
            font-size: 1rem;
            letter-spacing: 2px;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        /* Shield Status Indicator */
        #shield-status {
            font-size: 0.8rem;
            color: #00ccff;
            text-shadow: 0 0 10px #00ccff;
            margin-top: 5px;
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: bold;
            letter-spacing: 2px;
        }
        .shield-active { opacity: 1 !important; }

        /* Level Up Overlay Text */
        #level-up-msg {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 4rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 30px #fff;
            pointer-events: none;
            white-space: nowrap;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 15;
        }

        .level-up-active {
            opacity: 1 !important;
            transform: translate(-50%, -50%) scale(1) !important;
        }

        #mode-indicator {
            position: absolute;
            top: 180px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 900;
            letter-spacing: 5px;
            color: #d0f;
            text-shadow: 0 0 20px #d0f;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s;
        }

        .mode-active {
            opacity: 1 !important;
            transform: scale(1.2) !important;
            animation: pulseText 0.5s infinite alternate;
        }

        @keyframes pulseText {
            from { text-shadow: 0 0 10px #d0f; }
            to { text-shadow: 0 0 30px #fff, 0 0 10px #d0f; }
        }

        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            backdrop-filter: blur(4px);
        }

        .card {
            background: rgba(10, 10, 10, 0.95);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid #fff;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.15);
            text-align: center;
            max-width: 85%;
            width: 320px;
            pointer-events: auto;
        }

        h1 { color: #fff; margin: 0 0 10px 0; font-size: 1.8rem; text-transform: uppercase; letter-spacing: 2px; }
        p { color: #aaa; margin: 5px 0; line-height: 1.4; font-size: 0.9rem; }

        .legend {
            margin: 15px 0 25px 0; text-align: left; font-size: 0.85rem;
            background: rgba(255,255,255,0.05); padding: 10px; border-radius: 10px;
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 10px; display: inline-block; }
        
        .btn {
            background: transparent; color: #fff; border: 2px solid #fff;
            padding: 12px 35px; font-size: 1.1rem; font-family: 'Orbitron', sans-serif; font-weight: bold;
            cursor: pointer; text-transform: uppercase; border-radius: 50px;
            transition: all 0.1s; margin-top: 10px; outline: none;
        }
        .btn:active { background: #fff; color: #000; transform: scale(0.95); }

        .hidden { display: none !important; }
        .red-text { color: #ff3333; }
        .purple-text { color: #d0f; font-weight: bold; text-shadow: 0 0 5px #d0f;}
        .blue-text { color: #00ccff; font-weight: bold; text-shadow: 0 0 5px #00ccff;}

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="top-hud">
            <div class="score-container">
                <div id="level-display">LEVEL 1</div>
                <div id="score">0</div>
                <div id="shield-status">SHIELD ACTIVE</div>
            </div>
        </div>
        <div id="mode-indicator">SINGULARITY ACTIVE</div>
        <div id="level-up-msg">LEVEL UP!</div>
    </div>

    <div id="startScreen" class="screen-overlay">
        <div class="card" id="startCard">
            <h1>Neon Orbit</h1>
            <div class="legend">
                <div class="legend-item"><span class="dot" style="background:#ff3333;"></span>Avoid Enemies</div>
                <div class="legend-item"><span class="dot" style="background:#39ff14;"></span>Collect Points (+5)</div>
                <div class="legend-item"><span class="dot" style="background:#00ccff;"></span><span class="blue-text">Shield Orb</span> (Protect)</div>
                <div class="legend-item"><span class="dot" style="background:#d0f;"></span><span class="purple-text">Void Orb</span> (Power)</div>
            </div>
            <p>Tap to change direction.<br>Pass close to enemies for bonus!</p>
            <button class="btn" id="startBtn">INITIATE</button>
        </div>
    </div>

    <div id="gameOverScreen" class="screen-overlay hidden">
        <div class="card" id="gameOverCard">
            <h1 class="red-text">SYSTEM FAILURE</h1>
            <p>Final Level: <span id="finalLevel">1</span></p>
            <p>Score: <span id="finalScore" style="color:#fff; font-size:1.5rem;">0</span></p>
            <button class="btn" id="restartBtn">REBOOT</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- THEMES ---
        const THEMES = [
            { name: "CYBER", bg: '#050505', player: '#0ff', enemy: '#ff3333', ui: '#0ff' },
            { name: "PLASMA", bg: '#150015', player: '#ff00ff', enemy: '#00ffff', ui: '#ff00ff' },
            { name: "TOXIC",  bg: '#001000', player: '#39ff14', enemy: '#ff0055', ui: '#39ff14' },
            { name: "SOLAR",  bg: '#100500', player: '#ffaa00', enemy: '#0088ff', ui: '#ffaa00' },
            { name: "FROST",  bg: '#000510', player: '#00ffff', enemy: '#ffaa00', ui: '#00ffff' }
        ];

        // --- STATE ---
        let isPlaying = false;
        let score = 0;
        let level = 1;
        let currentTheme = THEMES[0];
        
        let lastTime = 0;
        let gameTime = 0;
        let timeScale = 1.0;
        let gameDifficultyMultiplier = 1.0;
        
        let isSingularity = false;
        let singularityTimer = 0;
        const SINGULARITY_DURATION = 6.0;

        let flashIntensity = 0;
        let isGameOverProcessing = false;

        // --- RESIZE ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- ENTITIES ---
        const player = {
            orbitRadius: 100,
            angle: 0,
            baseSpeed: 1.8, 
            direction: 1,
            size: 12,
            tail: [],
            hasShield: false,
            invulnerableTimer: 0 // Time remaining for post-hit invulnerability
        };

        let enemies = [];
        let bonuses = [];
        let voidOrbs = [];
        let shieldOrbs = []; // New Entity
        let particles = [];
        let floatTexts = [];
        let shockwaves = [];
        let stars = []; // Background

        // --- BACKGROUND STARS ---
        class Star {
            constructor() {
                this.x = (Math.random() - 0.5) * canvas.width * 2;
                this.y = (Math.random() - 0.5) * canvas.height * 2;
                this.z = Math.random() * 2 + 0.5; // Depth
                this.size = Math.random() * 1.5;
            }
            draw() {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                // Simple rotation
                const rotSpeed = 0.1 * timeScale;
                const oldX = this.x;
                const oldY = this.y;
                this.x = oldX * Math.cos(rotSpeed * 0.005) - oldY * Math.sin(rotSpeed * 0.005);
                this.y = oldX * Math.sin(rotSpeed * 0.005) + oldY * Math.cos(rotSpeed * 0.005);
                
                ctx.fillStyle = `rgba(255,255,255,${0.3 * this.z})`;
                ctx.beginPath();
                ctx.arc(cx + this.x, cy + this.y, this.size * this.z, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // Init Stars
        for(let i=0; i<80; i++) stars.push(new Star());

        class Enemy {
            constructor(forceOutsideSpawn = false) {
                this.angle = Math.random() * Math.PI * 2;
                this.distance = 0;
                this.baseSpeed = (60 + Math.random() * 60); 
                this.size = 16;
                this.isSucked = false;
                this.nearMissed = false; // Track if player already got bonus for this enemy

                if (forceOutsideSpawn) {
                    this.distance = Math.max(canvas.width, canvas.height) * 0.6;
                    this.isSucked = true;
                    this.baseSpeed = (150 + Math.random() * 100);
                }
            }
            update(dt) {
                const currentSpeed = this.baseSpeed * gameDifficultyMultiplier * dt;
                if (this.isSucked) {
                    this.distance -= currentSpeed;
                    this.angle += 1.0 * dt; 
                } else {
                    this.distance += currentSpeed;
                }
            }
            draw() {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const x = cx + Math.cos(this.angle) * this.distance;
                const y = cy + Math.sin(this.angle) * this.distance;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.angle + (this.isSucked ? gameTime * 5 : 0));
                
                if (this.isSucked) {
                    ctx.fillStyle = '#90f'; ctx.shadowColor = '#d0f'; ctx.shadowBlur = 20;
                } else {
                    ctx.fillStyle = currentTheme.enemy; ctx.shadowColor = currentTheme.enemy; ctx.shadowBlur = 15;
                }

                ctx.beginPath();
                ctx.moveTo(0, -this.size/1.5); ctx.lineTo(this.size/1.5, 0);
                ctx.lineTo(0, this.size/1.5); ctx.lineTo(-this.size/1.5, 0);
                ctx.fill();
                ctx.restore();
            }
        }

        class Bonus {
            constructor(type) {
                this.type = type || 'point'; // 'point', 'void', 'shield'
                this.angle = Math.random() * Math.PI * 2;
                this.distance = 0;
                this.baseSpeed = (70 + Math.random() * 50) * (this.type === 'point' ? 1.2 : 1.5); 
                this.size = this.type === 'point' ? 10 : 14;
            }
            update(dt) { this.distance += this.baseSpeed * gameDifficultyMultiplier * dt; }
            draw() {
                let mainColor, coreColor;
                if (this.type === 'point') { mainColor = '#fff'; coreColor = currentTheme.player; }
                else if (this.type === 'void') { mainColor = '#d0f'; coreColor = '#fff'; }
                else if (this.type === 'shield') { mainColor = '#00ccff'; coreColor = '#fff'; }
                
                drawOrb(this.distance, this.angle, this.size, mainColor, coreColor); 
            }
        }

        function drawOrb(dist, angle, size, mainColor, coreColor) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const x = cx + Math.cos(angle) * dist;
            const y = cy + Math.sin(angle) * dist;
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = mainColor; ctx.shadowBlur = 20; ctx.shadowColor = mainColor;
            ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = coreColor;
            ctx.beginPath(); ctx.arc(0, 0, size/2, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }

        class Shockwave {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.radius = 10; this.life = 1.0;
            }
            update(dt) { this.radius += 500 * dt; this.life -= 2.0 * dt; }
            draw() {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
                ctx.strokeStyle = this.color; ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke(); ctx.restore();
            }
        }

        class FloatingText {
            constructor(x, y, text, size, color) {
                this.x = x; this.y = y; this.text = text;
                this.size = size; this.color = color;
                this.life = 1.0; this.vy = -100;
            }
            update(dt) { this.y += this.vy * dt; this.life -= 1.5 * dt; }
            draw() {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px Orbitron`;
                ctx.textAlign = 'center'; ctx.fillText(this.text, this.x, this.y); ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.size = Math.random() * 4 + 2;
                const ang = Math.random() * Math.PI * 2;
                const spd = (150 + Math.random() * 150);
                this.vx = Math.cos(ang) * spd; this.vy = Math.sin(ang) * spd;
                this.life = 1.0; this.decay = 1.5 + Math.random();
            }
            update(dt) { 
                this.x += this.vx * dt; this.y += this.vy * dt; 
                this.life -= this.decay * dt; 
            }
            draw() {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color; ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill(); ctx.restore();
            }
        }

        // --- INPUT ---
        function handleInput() {
            if (isPlaying && !isGameOverProcessing) {
                player.direction *= -1;
            }
        }
        document.addEventListener('mousedown', (e) => { if(e.target.tagName !== 'BUTTON') handleInput(); });
        document.addEventListener('keydown', (e) => { if(e.code === 'Space') handleInput(); });
        document.addEventListener('touchstart', (e) => { if(e.target.tagName !== 'BUTTON' && isPlaying) { e.preventDefault(); handleInput(); } }, {passive: false});

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);

        // --- CORE LOGIC ---

        function applyTheme(themeIndex) {
            currentTheme = THEMES[themeIndex % THEMES.length];
            document.body.style.backgroundColor = currentTheme.bg;
            
            // Update UI Colors
            const elements = document.querySelectorAll('.card, .btn');
            elements.forEach(el => {
                el.style.borderColor = currentTheme.ui;
                el.style.color = currentTheme.ui;
                el.style.boxShadow = `0 0 20px ${currentTheme.ui}40`;
            });
            document.querySelector('.score-container').style.color = currentTheme.ui;
            document.querySelector('.score-container').style.textShadow = `0 0 10px ${currentTheme.ui}`;
        }

        function checkLevelUp() {
            const newLevel = Math.floor(score / 20) + 1;
            if (newLevel > level) {
                level = newLevel;
                levelUpEffect();
            }
        }

        function levelUpEffect() {
            applyTheme(level - 1);
            document.getElementById('level-display').innerText = `LEVEL ${level}`;
            const msg = document.getElementById('level-up-msg');
            msg.innerText = `LEVEL ${level}`;
            msg.classList.add('level-up-active');
            timeScale = 0.2;
            setTimeout(() => { timeScale = 1.0; }, 800);
            flashIntensity = 1.0;
            setTimeout(() => { msg.classList.remove('level-up-active'); }, 1500);
            enemies.forEach(e => e.distance += 50);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('mode-indicator').classList.remove('mode-active');

            score = 0; level = 1;
            applyTheme(0);
            document.getElementById('level-display').innerText = `LEVEL 1`;

            gameDifficultyMultiplier = 1.0; gameTime = 0; timeScale = 1.0;
            
            enemies = []; bonuses = []; voidOrbs = []; shieldOrbs = [];
            particles = []; floatTexts = []; shockwaves = [];
            
            isSingularity = false; singularityTimer = 0;
            isGameOverProcessing = false;

            player.angle = 0; player.direction = 1; player.tail = [];
            player.orbitRadius = Math.min(canvas.width, canvas.height) * 0.30;
            player.hasShield = false; player.invulnerableTimer = 0;
            updateShieldUI();

            isPlaying = true; lastTime = performance.now(); 
            updateScoreUI();
            
            requestAnimationFrame(gameLoop);
        }

        function updateScoreUI(pop) {
            const el = document.getElementById('score');
            el.innerText = score;
            if(pop) {
                el.style.transform = "scale(1.4)";
                setTimeout(() => { el.style.transform = "scale(1)"; }, 150);
            }
        }
        
        function updateShieldUI() {
            const el = document.getElementById('shield-status');
            if (player.hasShield) el.classList.add('shield-active');
            else el.classList.remove('shield-active');
        }

        function gameOver() {
      
